<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>TU/e Unbalanced Disk — Keyboard Control</title>
<style>
  :root{
    --bg:#0f172a; --panel:#111827; --ink:#e5e7eb; --muted:#9ca3af; --accent:#60a5fa; --good:#22c55e; --bad:#ef4444;
  }
  html,body{margin:0;height:100%;background:var(--bg);color:var(--ink);font:14px/1.4 system-ui,Segoe UI,Inter,Arial;}
  .wrap{max-width:1200px;margin:0 auto;padding:20px;display:grid;grid-template-columns:380px 1fr;gap:20px;}
  header{grid-column:1/-1;display:flex;align-items:center;gap:16px}
  .logo{display:inline-flex;align-items:center;gap:10px}
  .logo svg{height:36px}
  .card{background:var(--panel);border-radius:16px;padding:16px;box-shadow:0 10px 30px rgba(0,0,0,.3)}
  h1{font-size:20px;margin:0}
  h2{margin:0 0 12px 0;font-size:16px;color:var(--muted)}
  .row{display:flex;align-items:center;justify-content:space-between;gap:10px;margin:10px 0}
  .row label{color:var(--muted)}
  .row input[type="range"]{width:180px}
  .pill{display:flex;background:#0b1222;border-radius:999px;overflow:hidden}
  .pill button{all:unset;padding:6px 12px;cursor:pointer;color:var(--muted)}
  .pill button.active{background:#1f2a44;color:#fff}
  .hint{color:var(--muted);font-size:12px}
  .stats{display:grid;grid-template-columns:repeat(3,1fr);gap:10px;margin-top:10px}
  .stat{background:#0b1222;border-radius:12px;padding:10px;text-align:center}
  .stat .big{font-size:18px;font-weight:700}
  canvas{width:100%;height:100%;display:block;background:#0b1222;border-radius:16px}
  .controls{display:flex;flex-wrap:wrap;gap:8px}
  .controls button{background:#1f2a44;color:#fff;border:0;border-radius:10px;padding:8px 12px;cursor:pointer}
  .controls button.primary{background:var(--accent);color:#00112a}
  .controls button:disabled{opacity:.5;cursor:not-allowed}
  .right header h1{font-size:18px}
  .hidden{display:none}
  .ok{color:var(--good)} .bad{color:var(--bad)}
  .note{margin-top:6px;color:var(--muted);font-size:12px}
  .split{display:grid;grid-template-columns:1fr 1fr;gap:12px}
</style>
</head>
<body>
  <div class="wrap">
    <header>
      <div class="logo" aria-label="TU/e">
        <!-- Simple TU/e mark -->
        <svg viewBox="0 0 120 40" role="img" aria-hidden="true">
          <rect width="120" height="40" rx="8" fill="#0b1222"/>
          <text x="14" y="27" font-size="24" fill="#ffffff" font-family="ui-sans-serif,system-ui,Segoe UI,Inter,Arial">TU/<tspan fill="#60a5fa">e</tspan></text>
        </svg>
      </div>
      <h1>Unbalanced Disk — Keyboard Control</h1>
    </header>

    <!-- LEFT: Settings & Stats -->
    <section class="card">
      <h2>Settings</h2>

      <div class="row">
        <label>Mode</label>
        <div class="pill" role="tablist">
          <button id="mode-no" class="active" role="tab" aria-selected="true">No tracking</button>
          <button id="mode-tr" role="tab" aria-selected="false">Tracking</button>
        </div>
      </div>

      <div id="ref-row" class="row hidden">
        <label>Ref amplitude: <span id="amp-label">15°</span></label>
        <input id="amp" type="range" min="2" max="45" step="1" value="15" />
      </div>

      <div class="row">
        <label>dt (s): <span id="dt-label">0.025</span></label>
        <input id="dt" type="range" min="0.005" max="0.05" step="0.001" value="0.025" />
      </div>

      <div class="row">
        <label>Difficulty (slice half-width)</label>
        <div class="pill" id="diff-pill" aria-label="Difficulty">
          <button data-deg="15" class="active">Easy</button>
          <button data-deg="8">Medium</button>
          <button data-deg="4">Hard</button>
        </div>
      </div>
      <div class="hint">Arrow keys (or A/D) = torque. Z = auto-zero toggle. SPACE = pause. R = reset.</div>

      <div class="controls" style="margin-top:12px">
        <button id="start" class="primary">Start (20s)</button>
        <button id="pause">Pause</button>
        <button id="reset">Reset</button>
        <button id="download">Download logs (.zip)</button>
      </div>

      <div class="stats">
        <div class="stat">
          <div class="hint">Time</div>
          <div class="big" id="time">0.00 s</div>
        </div>
        <div class="stat">
          <div class="hint">Inside slice</div>
          <div class="big" id="inside">0.00 s</div>
        </div>
        <div class="stat">
          <div class="hint">Score</div>
          <div class="big" id="score">0.0%</div>
        </div>
      </div>
      <div class="split" style="margin-top:10px">
        <div>
          <div class="hint">θ (deg)</div>
          <div class="big" id="theta-deg">0.0</div>
        </div>
        <div>
          <div class="hint">u / umax</div>
          <div class="big" id="u-view">0.00</div>
        </div>
      </div>
      <div class="note" id="status">Ready. Press <b>Start</b> and use ←/→ (or A/D).</div>
    </section>

    <!-- RIGHT: Canvas -->
    <section class="card right">
      <header><h1>Arena</h1></header>
      <canvas id="cv" width="820" height="820"></canvas>
    </section>
  </div>

  <!-- JSZip for downloading logs as a single ZIP -->
  <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>

<script>
/* ==== Helpers ==== */
const TAU = Math.PI*2;
const clamp=(x,a,b)=>Math.max(a,Math.min(b,x));
const deg2rad=d=>d*Math.PI/180;
const rad2deg=r=>r*180/Math.PI;
const wrapPi = a => ((a + Math.PI) % (2*Math.PI) + (2*Math.PI)) % (2*Math.PI) - Math.PI;

/* ==== Environment dynamics (like your Python env) ==== */
class DiskEnv {
  constructor({dt=0.025, umax=3}={}){
    // --- do not edit: same constants as your Python env ---
    this.omega0 = 11.339846957335382;
    this.delta_th = 0;
    this.gamma = 1.3328339309394384;
    this.Ku = 28.136158407237073;
    this.Fc = 6.062729509386865;
    this.coulomb_omega = 0.001;
    // ------------------------------------------------------
    this.dt = dt;
    this.umax = umax;
    this.reset();
  }
  reset(){
    // Start disk DOWN at 6 o’clock: theta = 0 rad (bottom)
    this.th = 0; // np.random.normal(0, small) could be added
    this.om = 0;
    return [this.th, this.om];
  }
  step(u){
    // clamp & integrate
    u = clamp(u, -this.umax, this.umax);
    const friction = this.gamma * this.om + this.Fc * Math.tanh(this.om / this.coulomb_omega);
    const dom = -this.omega0*this.omega0 * Math.sin(this.th + this.delta_th) - friction + this.Ku * u;
    this.om += this.dt * dom;
    this.th += this.dt * this.om;
    return [this.th, this.om];
  }
}

/* ==== Game state ==== */
const state = {
  mode: "no",        // 'no' | 'tr'
  dt: 0.025,
  umax: 3,
  uStep: 0.15,
  autoZero: true,
  playing: false,
  paused: false,
  t: 0,
  Tfinal: 20.0,
  insideTime: 0,
  bestScore: 0,
  logs: [], // {name, csv}
  // control
  u: 0,
  keys: {left:false,right:false,a:false,d:false,z:false},
  // refs
  refAmp: deg2rad(15),
  refFreq: 0.25, // Hz
  sliceHalf: deg2rad(15),
  // physics
  env: null,
  // previous for sub-dt scoring
  prev: {theta:0, ref:0}
};

/* ==== UI ==== */
const el = {
  modeNo: document.getElementById('mode-no'),
  modeTr: document.getElementById('mode-tr'),
  refRow: document.getElementById('ref-row'),
  amp: document.getElementById('amp'),
  ampLabel: document.getElementById('amp-label'),
  dt: document.getElementById('dt'),
  dtLabel: document.getElementById('dt-label'),
  diffPill: document.getElementById('diff-pill'),
  start: document.getElementById('start'),
  pause: document.getElementById('pause'),
  reset: document.getElementById('reset'),
  download: document.getElementById('download'),
  time: document.getElementById('time'),
  inside: document.getElementById('inside'),
  score: document.getElementById('score'),
  thetaDeg: document.getElementById('theta-deg'),
  uView: document.getElementById('u-view'),
  status: document.getElementById('status'),
  cv: document.getElementById('cv')
};
const ctx = el.cv.getContext('2d');

/* ==== Drawing ==== */
function draw(){
  const W = el.cv.width, H = el.cv.height;
  const cx=W/2, cy=H/2, R=Math.min(W,H)*0.33, massR=R*0.3;
  ctx.clearRect(0,0,W,H);

  // background ring
  ctx.save();
  ctx.translate(cx,cy);
  ctx.fillStyle = "#0b1222";
  ctx.beginPath(); ctx.arc(0,0,R*1.5,0,TAU); ctx.fill();

  // reference slice
  const thRef = currentRef(state.t);
  const hw = state.sliceHalf;
  const inside = isInsideSlice(state.env.th, thRef, hw);
  ctx.globalAlpha = 0.3;
  ctx.fillStyle = inside ? "#22c55e" : "#ef4444";
  ctx.beginPath();
  ctx.moveTo(0,0);
  ctx.arc(0,0,R+massR*1.1, thRef-hw - Math.PI/2, thRef+hw - Math.PI/2, false); // rotate so 0 rad points downwards visually
  ctx.closePath(); ctx.fill();
  ctx.globalAlpha = 1;

  // reference mark
  ctx.strokeStyle = inside ? "#22c55e" : "#ef4444";
  ctx.lineWidth = 3;
  ctx.beginPath();
  const rx = 0 + Math.sin(thRef)*R;
  const ry = 0 + Math.cos(thRef)*R;
  ctx.moveTo(0,0); ctx.lineTo(rx, ry); ctx.stroke();

  // disk axis
  ctx.strokeStyle = "#334155";
  ctx.lineWidth = 2;
  ctx.beginPath(); ctx.arc(0,0, R, 0, TAU); ctx.stroke();

  // moving mass (theta=0 at bottom; use x=sin, y=cos to place at 6 o'clock for 0 rad)
  const th = state.env.th;
  const mx = Math.sin(th)*R;
  const my = Math.cos(th)*R;
  // connection rod
  ctx.strokeStyle = "#93c5fd"; ctx.lineWidth = 4;
  ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(mx,my); ctx.stroke();
  // mass
  ctx.fillStyle = "#f59e0b";
  ctx.beginPath(); ctx.arc(mx,my, massR, 0, TAU); ctx.fill();
  // hub
  ctx.fillStyle = "#94a3b8"; ctx.beginPath(); ctx.arc(0,0, R*0.08, 0, TAU); ctx.fill();

  // torque bar
  const uNorm = state.u / state.umax;
  const barLen = Math.abs(uNorm) * (W*0.18);
  ctx.fillStyle = uNorm>=0 ? "#ef4444" : "#60a5fa";
  ctx.fillRect(-barLen/2, R*1.4, barLen, 12);

  ctx.restore();
}

/* ==== Reference & inside logic ==== */
function currentRef(t){
  if(state.mode==="no") return Math.PI; // upright reference
  return state.refAmp * Math.sin(2*Math.PI*state.refFreq*t) + Math.PI; // oscillate around upright
}
function isInsideSlice(theta, thetaRef, halfWidth){
  // compute wrapped error around reference
  const err = wrapPi(theta - thetaRef);
  return Math.abs(err) <= halfWidth;
}

/* ==== Sub-dt scoring (fraction of dt inside the slice) ==== */
function fractionInsideOverStep(th0, th1, ref0, ref1, halfWidth, samples=32){
  // Linear interpolation between (th0,ref0) -> (th1,ref1) on the circle using unwrap
  const dth = wrapPi(th1 - th0);  // shortest arc
  const dref = wrapPi(ref1 - ref0);
  let count=0;
  for(let i=0;i<samples;i++){
    const a = i/(samples-1);
    const th = wrapPi(th0 + a*dth);
    const rf = wrapPi(ref0 + a*dref);
    if(Math.abs(wrapPi(th - rf)) <= halfWidth) count++;
  }
  return count / samples;
}

/* ==== Keyboard torque logic (your snippet behavior) ==== */
function updateTorque(){
  let delta = 0.0;
  const left = state.keys.left || state.keys.a;
  const right = state.keys.right || state.keys.d;
  const nearBottom = Math.abs(state.env.th) < deg2rad(70); // "far from top" ~ near bottom region

  if(left){
    if(nearBottom) state.u =  state.umax; // full power
    else delta -= state.uStep;            // gentle push
  } else if(right){
    if(nearBottom) state.u = -state.umax;
    else delta += state.uStep;
  } else {
    state.u = 0.0; // no keys -> neutral (then auto-zero may smooth residual)
  }

  if(delta === 0.0 && state.autoZero){
    state.u *= 0.95;
  }
  state.u = clamp(state.u + delta, -state.umax, state.umax);
}

/* ==== Main loop ==== */
let rafId=null, lastTime=null;
function loop(ts){
  if(!state.playing || state.paused){ lastTime = ts; draw(); return; }
  if(lastTime==null) lastTime = ts;
  // fixed step using configured dt; drive wall-time to simulation-time
  const dt = state.dt;

  // control
  updateTorque();

  // previous for scoring
  const th0 = state.env.th;
  const rf0 = currentRef(state.t);

  // integrate 1 step
  state.env.dt = dt;
  state.env.step(state.u);
  state.t += dt;

  const th1 = state.env.th;
  const rf1 = currentRef(state.t);

  // score: fraction of dt inside using fine sampling (sub-dt interpolation)
  const frac = fractionInsideOverStep(th0, th1, rf0, rf1, state.sliceHalf, 32);
  state.insideTime += dt * frac;

  // UI
  const pct = 100 * (state.insideTime / Math.max(state.t,1e-9));
  el.time.textContent   = state.t.toFixed(2) + " s";
  el.inside.textContent = state.insideTime.toFixed(2) + " s";
  el.score.textContent  = pct.toFixed(1) + "%";
  el.thetaDeg.textContent = rad2deg(wrapPi(state.env.th)).toFixed(1);
  el.uView.textContent  = (state.u/state.umax).toFixed(2);
  el.status.innerHTML = isInsideSlice(state.env.th, rf1, state.sliceHalf)
    ? '<span class="ok">Inside slice — scoring…</span>'
    : '<span class="bad">Outside slice</span>';

  draw();

  // Stop at 20s
  if(state.t >= state.Tfinal){
    endRun();
  }

  rafId = requestAnimationFrame(loop);
}

/* ==== Run control & logging ==== */
let currentLog = null;
function startRun(){
  if(state.playing) return;
  // init
  state.env = new DiskEnv({dt: state.dt, umax: state.umax});
  state.t = 0; state.insideTime = 0; state.u = 0;
  state.playing = true; state.paused = false;
  el.start.disabled = true; el.pause.disabled = false;
  el.status.textContent = "Running…";
  // start log
  currentLog = { rows: [], started: new Date() };
  // kick loop
  cancelAnimationFrame(rafId); lastTime=null;
  rafId = requestAnimationFrame(loop);
}
function endRun(){
  state.playing = false; el.start.disabled = false; el.pause.disabled = true;
  const scorePct = 100 * (state.insideTime / Math.max(state.t,1e-9));
  const name = `${currentLog.started.toISOString().replace(/[:.]/g,'-')}_score-${scorePct.toFixed(1)}.csv`;
  // finalize CSV
  const csv = "t,theta,omega,u,theta_ref,inside\n" + currentLog.rows.map(r=>r.join(",")).join("\n");
  // save only if better than previous best
  if(scorePct > state.bestScore){
    state.bestScore = scorePct;
    state.logs.push({name, csv});
    el.status.innerHTML = `<b>Finished.</b> New best score: ${scorePct.toFixed(1)}%. Saved log "${name}".`;
  } else {
    el.status.innerHTML = `<b>Finished.</b> Score: ${scorePct.toFixed(1)}%. (Not better than best ${state.bestScore.toFixed(1)}%)`;
  }
  draw();
}
function togglePause(){
  if(!state.playing) return;
  state.paused = !state.paused;
  el.pause.textContent = state.paused ? "Resume" : "Pause";
  if(!state.paused) { lastTime=null; rafId=requestAnimationFrame(loop); }
}
function resetAll(){
  state.playing=false; state.paused=false; cancelAnimationFrame(rafId);
  state.env = new DiskEnv({dt: state.dt, umax: state.umax});
  state.t=0; state.insideTime=0; state.u=0; lastTime=null;
  el.time.textContent="0.00 s"; el.inside.textContent="0.00 s"; el.score.textContent="0.0%";
  el.pause.textContent="Pause"; el.start.disabled=false; el.pause.disabled=false;
  el.status.textContent="Reset. Ready.";
  draw();
}

/* ==== Capture log each visual frame (after physics) ==== */
(function hookLogging(){
  const origStep = DiskEnv.prototype.step;
  DiskEnv.prototype.step = function(u){
    const [thPrev, omPrev] = [this.th, this.om];
    const out = origStep.call(this, u);
    if(currentLog && state.playing){
      const ref = currentRef(state.t + 0); // after step, use current t
      const inside = isInsideSlice(this.th, ref, state.sliceHalf) ? 1 : 0;
      currentLog.rows.push([
        state.t.toFixed(4), this.th.toFixed(6), this.om.toFixed(6), u.toFixed(6),
        ref.toFixed(6), inside
      ]);
    }
    return out;
  }
})();

/* ==== Events ==== */
el.modeNo.onclick = ()=>{ state.mode="no"; el.modeNo.classList.add('active'); el.modeTr.classList.remove('active'); el.refRow.classList.add('hidden'); };
el.modeTr.onclick = ()=>{ state.mode="tr"; el.modeTr.classList.add('active'); el.modeNo.classList.remove('active'); el.refRow.classList.remove('hidden'); };
el.amp.oninput = e=>{ el.ampLabel.textContent = `${e.target.value}°`; state.refAmp = deg2rad(+e.target.value); };
el.dt.oninput  = e=>{ state.dt = +e.target.value; el.dtLabel.textContent = state.dt.toFixed(3); };
[...el.diffPill.querySelectorAll('button')].forEach(btn=>{
  btn.onclick = ()=>{
    [...el.diffPill.querySelectorAll('button')].forEach(b=>b.classList.remove('active'));
    btn.classList.add('active');
    state.sliceHalf = deg2rad(+btn.dataset.deg);
  };
});

el.start.onclick = startRun;
el.pause.onclick = togglePause;
el.reset.onclick = resetAll;

el.download.onclick = async ()=>{
  if(state.logs.length===0){ el.status.textContent="No saved logs yet (beat your best score to save)."; return; }
  const zip = new JSZip();
  state.logs.forEach(({name,csv})=>zip.file(name, csv));
  const blob = await zip.generateAsync({type:"blob"});
  const a = document.createElement('a'); a.href = URL.createObjectURL(blob);
  a.download = "disk-logs.zip"; a.click(); URL.revokeObjectURL(a.href);
};

window.addEventListener('keydown', e=>{
  if(e.repeat) return;
  if(e.key==="ArrowLeft") state.keys.left = true;
  if(e.key==="ArrowRight") state.keys.right = true;
  if(e.key==="a"||e.key==="A") state.keys.a = true;
  if(e.key==="d"||e.key==="D") state.keys.d = true;
  if(e.key===" ") togglePause();
  if(e.key==="r"||e.key==="R") resetAll();
  if(e.key==="z"||e.key==="Z"){ state.autoZero = !state.autoZero; el.status.textContent = `Auto-zero: ${state.autoZero?'ON':'OFF'}`; }
});
window.addEventListener('keyup', e=>{
  if(e.key==="ArrowLeft") state.keys.left = false;
  if(e.key==="ArrowRight") state.keys.right = false;
  if(e.key==="a"||e.key==="A") state.keys.a = false;
  if(e.key==="d"||e.key==="D") state.keys.d = false;
});

function init(){
  state.env = new DiskEnv({dt: state.dt, umax: state.umax});
  draw();
}
init();
</script>
</body>
</html>